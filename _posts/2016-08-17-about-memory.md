---
layout: post
title: 关于内存的一些理解和总结
category: KVM虚拟化
tags: [MMU, linux, 内核页表]
keywords: MMU, linux, 内核页表
description: 
---

> 用正确的工具，做正确的事情

## 1. 内存技术的发展
早期的计算机，程序直接使用并运行在物理内存上，存在的问题是：

> 内存使用率低，运行的程序需要全部调入物理内存才可以运用，这有可能导致物理内存不足，32k内存的计算机没法运行64k的程序，另外一个问题是对于多任务系统。                                                            

为了解决这个问题，操作系统发展出了虚拟内存的概念，执行的程序不需要一次全部调入物理内存，根据程序运行的“局部性”原理，只要将程序当前执行的代码片段及相关数据调入物理内存即可执行，程序其他部分继续存放在计算机硬盘上，当执行到时再将要执行的代码及数据片段调入物理内存，执行完的代码片段和数据可以根据一定的策略从物理内存调出到硬盘。支持虚拟内存的计算机系统，程序使用虚拟地址来访问内存，然后利用内核机制及硬件功能单元将虚拟地址映射成物理内存，来实现对真实物理内存的访问，因此虚拟内存实现的主要目标是：

> 虚拟地址空间的管理以及虚拟地址翻译成物理地址的实现机制。

paging技术是实现虚拟内存的一种方式，paging技术的实现主要依赖于硬件MMU及内核页表技术，下面是从硬件及内核层面来观察不同模块所实现的功能。


## 2. 硬件层面
在硬件层面上观察，跟内存相关的硬件功能模块，比较重要的两个功能单元包括MMU、CR3寄存器。 MMU是集成在CPU芯片上的一个硬件功能模块，在硬件上实现了对分页技术的支持，实现虚拟地址向物理地址的转化，CR3寄存器可以看成硬件层面向上层（内核）提供的接口，内核通过该接口可以使用硬件MMU实现的功能。从硬件架构上看CPU、MMU、虚拟地址、物理地址之间的关系，如下图，[引用](http://nieyong.github.io/wiki_cpu/CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-MMU.html)。

![CPU、MMU、虚拟地址、物理地址之间的关系](http://7u2rbh.com1.z0.glb.clouddn.com/mmu_va2pa.png)


对于OS来说，页表是进程私有的，因此各个进程的页表被放置在不同的物理内存中,在进程启动或者切换时，都必须把进程的页表的起始物理地址告诉MMU，内核通过写CR3寄存器将页表基地址告诉MMU， MMU通过对页表的遍历，专业术语叫TTW（Translation Table Walk）来实现从虚拟地址向物理地址的转换，MMU只是从硬件上实现了对页表的查找（页表的查找是通过硬件来实现，而不是通过软件在cpu上执行来实现的，通过专有硬件来加速的例子），页表的创建及管理是由内核来实现的，TTW的结果要么找到虚拟地址对应的物理地址，要么查找页表失败没有找到对应的页表项，产生缺页中断由内核来处理。


## 3. 内核层面

### 3.1 
	

### 3.2 linux 4级页表结构

页表结构

多级页表的意义

假设页的大小为4KB，那么对于页表的索引就需要使用VA的[31:12]，也就有1M个页表项，一个页表项4字节，可以算的页表的大小为4M。 这意味着这4M空间必须作为进程的必备资源在启动的时候一次分配，而且这4M的内存必须在物理地址上连续。 这和虚拟内存设计的理念（小内存系统上运行尽量多的程序）不相符合。解决的办法就是采用多级页表。


最大物理内存寻址范围的决定因素



## 4. 内存管理相关数据结构全局视图
