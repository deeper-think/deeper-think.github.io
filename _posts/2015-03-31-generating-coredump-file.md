---
layout: post
title: linux环境产生并调试coredump文件
category: 技术
tags: [gdb, coredump]
keywords: gdb, coredump
description: 
---

> 我思故我在 -- 笛卡尔

系统配置了coredump后，当程序异常终止时操作系统会在指定的目录下按指定的文件名格式产生一个core文件。core文件是程序内存映像以及相关的调试信息，通过gdb调试coredump文件可以知道导致程序异常终止的原因。


## 系统配置coredump
首先是打开coredump，通过ulimit命令看coredump是否开启：

    [root@localhost coredump]# ulimit -a
    core file size          (blocks, -c) unlimited
    data seg size           (kbytes, -d) unlimited
    scheduling priority             (-e) 0
    file size               (blocks, -f) unlimited
    pending signals                 (-i) 7903
    max locked memory       (kbytes, -l) 64
    max memory size         (kbytes, -m) unlimited
    open files                      (-n) 1024
    pipe size            (512 bytes, -p) 8
    POSIX message queues     (bytes, -q) 819200
    real-time priority              (-r) 0
    stack size              (kbytes, -s) 8192
    cpu time               (seconds, -t) unlimited
    max user processes              (-u) 7903
    virtual memory          (kbytes, -v) unlimited
    file locks                      (-x) unlimited

core file size配置项的值为unlimited，表明coredump已经打开，并且不限制core文件的大小。如果core file size配置项的值为0，表明coredump没有打开，可以通过命令：

    ulimit -c unlimited

来打开系统的coredump。

指定core文件的路径以及core文件的文件名格式：

    echo "1" > /proc/sys/kernel/core_uses_pid

core_uses_pid文件可以控制产生的core文件是否带pid，设置core_uses_pid为1使得产生的core文件以相应进程的pid作为文件尾。

    echo "/corefile/core-%e-%p-%t" > /proc/sys/kernel/core_pattern

core_pattern控制core文件的文件名格式以及core文件的产生路径，上面的命令使系统在/corefile目录下产生core文件，core文件的文件名格式类似于core-test-17129-1402996666(core-可执行程序名-进程pid号-产生时间)。

## 一个产生coredump文件的例子

下面程序会因为内存非法访问而产生一个段错误，导致程序异常终止，系统自动产生core文件。

    #include <stdio.h>
    #include <stdlib.h>
    
    void test()
    {
        char* s = "abc";
        *s = 'x';
    }
    
    int main(int argc, char** argv)
    {
        test();
        return (EXIT_SUCCESS);
    }

编译该程序并执行时，程序异常终止并产生core文件：

    [root@localhost coredump]# ./test
    Segmentation fault (core dumped)

## gdb调试coredump文件，确定程序异常终止的原因

到/corefile目录找到刚才程序产生的core文件，gdb调试该core文件：

    [root@localhost coredump]# gdb test /corefile/core-test-17525-1403006130
    GNU gdb (GDB) Red Hat Enterprise Linux (7.2-60.el6)
    Copyright (C) 2010 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
    and "show warranty" for details.
    This GDB was configured as "x86_64-redhat-linux-gnu".
    For bug reporting instructions, please see:
    <http://www.gnu.org/software/gdb/bugs/>...
    Reading symbols from /home/coredump/test...done.
    [New Thread 17525]
    Missing separate debuginfo for
    Try: yum --disablerepo='*' --enablerepo='*-debug*' install /usr/lib/debug/.build-id/30/19e7405069cf9fce3e07d2cc9f284ed6e5c40f
    Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done.
    Loaded symbols for /lib64/libc.so.6
    Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
    Loaded symbols for /lib64/ld-linux-x86-64.so.2
    Core was generated by `./test'.
    Program terminated with signal 11, Segmentation fault.
    #0  0x0000000000400484 in test () at test.c:7
              *s = 'x';
    Missing separate debuginfos, use: debuginfo-install glibc-2.12-1.107.el6.x86_64
    (gdb)

从上面的信息可以看出，导致程序异常终止的原因是发生了段错误，并且可以具体定位到引起段错误的程序语句。


enjoy the life !!!
